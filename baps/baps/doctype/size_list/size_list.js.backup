// ============================
// Size List - Simple Approval Workflow
// ============================
//             }
//             for (let i = start; i <= end; i++) numbers.push(i);
//         } else if (input.indexOf(',') !== -1) {
//             numbers = input.split(',').map(s => cint(s.trim())).filter(n => !isNaN(n));
//         } else {
//             let n = cint(input);
//             if (!isNaN(n)) numbers = [n];
//         }

//         numbers = [...new Set(numbers)].sort((a,b) => a-b);
//         if (numbers.length === 0) return;

//         // First row must have stone_code
//         if (!row.stone_code) {
//             frappe.show_alert({message: __("Please enter Stone Code in the first row before using range"), indicator: "red"});
//             return;
//         }

//         // let match = row.stone_code.match(/^(.*?)(\d+)$/);
//         // if (!match) {
//         //     frappe.show_alert({message: __("Stone Code must end with numbers, e.g. ABCDE001"), indicator: "red"});
//         //     return;
//         // }

//         let prefix = match[1], num_width = match[2].length;

//         // Clear range field
//         frappe.model.set_value(cdt, cdn, "range", "");

//         let duplicate_codes = [];

//         numbers.forEach((n, idx) => {
//             let stone_code = prefix + String(n).padStart(num_width, "0");

//             let exists = frm.doc.stone_details.some(r => r.stone_code === stone_code || r.serial_no === n);
//             if (exists) {
//                 duplicate_codes.push(stone_code);
//                 return;
//             }

//             let target_row;
//             if (idx === 0) {
//                 target_row = row;
//                 target_row.stone_code = stone_code;
//                 target_row.serial_no = n;
//             } else {
//                 target_row = frm.add_child("stone_details");
//                 Object.keys(row).forEach(f => {
//                     if (!["name","idx","doctype","stone_code","range","serial_no"].includes(f)) {
//                         target_row[f] = row[f];
//                     }
//                 });
//                 target_row.stone_code = stone_code;
//                 target_row.serial_no = n;
//             }

//             // Auto-inherit parent-level process flags (optional, for display/reference)
//             if (frm.doc.chemical !== undefined) target_row.chemical = frm.doc.chemical;
//             if (frm.doc.dry_fitting !== undefined) target_row.dry_fitting = frm.doc.dry_fitting;
//             if (frm.doc.polishing !== undefined) target_row.polishing = frm.doc.polishing;

//             calculate_volume(frm, target_row.doctype, target_row.name);
//         });

//         if (duplicate_codes.length) {
//             frappe.show_alert({
//                 message: __("Skipped duplicates: ") + duplicate_codes.join(", "),
//                 indicator: "orange"
//             });
//         }

//         frm.refresh_field("stone_details");
//     },

//     // --- Stone Code handler (auto-fill sequentially after manual entry) ---
//     stone_code: function(frm, cdt, cdn) {
//         let row = locals[cdt][cdn];
//         if (!row || !row.stone_code) return;

//         // let match = row.stone_code.match(/^(.*?)(\d+)$/);
//         // if (!match) {
//         //     frappe.msgprint(__("Stone Code must end with numbers, e.g. ABCDE001"));
//         //     return;
//         // }

//         let prefix = match[1];
//         let base_num = cint(match[2]);
//         let num_width = match[2].length;
//         let next_num = base_num + 1;

//         let all = frm.doc.stone_details || [];
//         let startIndex = all.findIndex(r => r.name === row.name);
//         if (startIndex === -1) return;

//         let existing = new Set(all.filter(r => r.stone_code).map(r => r.stone_code));
//         let duplicate_codes = [];

//         for (let i = startIndex + 1; i < all.length; i++) {
//             let r = all[i];
//             if (r.stone_code) {
//                 let m = r.stone_code.match(/^(.*?)(\d+)$/);
//                 if (m && m[1] === prefix) {
//                     next_num = cint(m[2]) + 1;
//                 }
//                 break;
//             }

//             let generated = prefix + String(next_num++).padStart(num_width, "0");
//             if (existing.has(generated)) {
//                 duplicate_codes.push(generated);
//             }

//             frappe.model.set_value(r.doctype, r.name, "stone_code", generated);
//             existing.add(generated);

//             // Inherit parent flags if needed
//             if (frm.doc.chemical !== undefined) r.chemical = frm.doc.chemical;
//             if (frm.doc.dry_fitting !== undefined) r.dry_fitting = frm.doc.dry_fitting;
//             if (frm.doc.polishing !== undefined) r.polishing = frm.doc.polishing;

//             calculate_volume(frm, r.doctype, r.name);
//         }

//         frm.refresh_field("stone_details");
//         update_total_volume(frm);

//         if (duplicate_codes.length > 0) {
//             let dupMsg = __("Warning: Duplicate Stone Codes detected → ") + [...new Set(duplicate_codes)].join(", ");
//             frappe.show_alert({ message: dupMsg, indicator: "orange" });
//         }
//     },

//     // --- Dimension fields with inch validation ---
//     l1: calculate_volume,
//     l2: function(frm, cdt, cdn) {
//         let row = locals[cdt][cdn];
//         if (row.l2 >= 12) {
//             frappe.msgprint(__('L2 must be less than 12 inches'));
//             frappe.model.set_value(cdt, cdn, 'l2', 0);
//         }
//         calculate_volume(frm, cdt, cdn);
//     },
//     b1: calculate_volume,
//     b2: function(frm, cdt, cdn) {
//         let row = locals[cdt][cdn];
//         if (row.b2 >= 12) {
//             frappe.msgprint(__('B2 must be less than 12 inches'));
//             frappe.model.set_value(cdt, cdn, 'b2', 0);
//         }
//         calculate_volume(frm, cdt, cdn);
//     },
//     h1: calculate_volume,
//     h2: function(frm, cdt, cdn) {
//         let row = locals[cdt][cdn];
//         if (row.h2 >= 12) {
//             frappe.msgprint(__('H2 must be less than 12 inches'));
//             frappe.model.set_value(cdt, cdn, 'h2', 0);
//         }
//         calculate_volume(frm, cdt, cdn);
//     },

//     stone_details_remove: function(frm) {
//         update_total_volume(frm);
//     },

//     refresh: function(frm, cdt, cdn) {
//         // Optional: If you want child rows to reflect parent values always
//         let row = locals[cdt][cdn];
//         if (row && frm.doc) {
//             if (frm.doc.chemical !== undefined) row.chemical = frm.doc.chemical;
//             if (frm.doc.dry_fitting !== undefined) row.dry_fitting = frm.doc.dry_fitting;
//             if (frm.doc.polishing !== undefined) row.polishing = frm.doc.polishing;
//         }
//     }
// });

// // --- Volume calculation for a single row ---
// function calculate_volume(frm, cdt, cdn) {
//     let row = locals[cdt][cdn];
//     if (!row) return;
//     let L = ((row.l1 || 0) * 12) + (row.l2 || 0);
//     let B = ((row.b1 || 0) * 12) + (row.b2 || 0);
//     let H = ((row.h1 || 0) * 12) + (row.h2 || 0);
//     row.volume = ((L * B * H) / 1728).toFixed(2);
//     frm.refresh_field('stone_details');
//     update_total_volume(frm);
// }

// // --- Total volume across all rows ---
// function update_total_volume(frm) {
//     let total = 0;
//     (frm.doc.stone_details || []).forEach(r => {
//         total += flt(r.volume);
//     });
//     frm.set_value('total_volume', total.toFixed(2));
// }

// // ============================
// // Parent Doctype: Size List
// // ============================
// frappe.ui.form.on('Size List', {
//     main_part: function(frm) {
//         if (!frm.doc.main_part) frm.set_value('sub_part', '');
//     },

//     sub_part: function(frm) {
//         if (!frm.doc.sub_part) frm.set_value('main_part', '');
//     },

//     refresh: function(frm) {
//         if (frm.doc.baps_project) {
//             load_project_flags(frm);
//         }
//         // Ensure child rows reflect current parent flags
//         sync_child_process_flags(frm);
//     },

//     baps_project: function(frm) {
//         if (frm.doc.baps_project) {
//             load_project_flags(frm);
//         } else {
//             frm.set_value({
//                 chemical: 0,
//                 dry_fitting: 0,
//                 polishing: 0
//             });
//             sync_child_process_flags(frm);
//         }
//     },

//     // When adding new row, inherit parent flags
//     stone_details_add: function(frm, cdt, cdn) {
//         let row = locals[cdt][cdn];
//         if (frm.doc.chemical !== undefined) row.chemical = frm.doc.chemical;
//         if (frm.doc.dry_fitting !== undefined) row.dry_fitting = frm.doc.dry_fitting;
//         if (frm.doc.polishing !== undefined) row.polishing = frm.doc.polishing;
//     },

//     // Optional: Sync whenever parent flags change
//     chemical: function(frm) {
//         sync_child_process_flags(frm);
//     },
//     dry_fitting: function(frm) {
//         sync_child_process_flags(frm);
//     },
//     polishing: function(frm) {
//         sync_child_process_flags(frm);
//     }
// });

// // --- Load project flags from linked Baps Project ---
// function load_project_flags(frm) {
//     if (!frm.doc.baps_project) {
//         frm.set_value({
//             chemical: 0,
//             dry_fitting: 0,
//             polishing: 0
//         });
//         return;
//     }

//     frappe.db.get_doc("Baps Project", frm.doc.baps_project).then(project => {
//         frm.set_value({
//             chemical: project.chemical ? 1 : 0,
//             dry_fitting: project.dry_fitting ? 1 : 0,
//             polishing: project.polishing ? 1 : 0
//         });
//         sync_child_process_flags(frm); // propagate to children
//     });
// }

// // --- Sync parent process flags to all child rows ---
// function sync_child_process_flags(frm) {
//     if (!frm.doc.stone_details) return;

//     frm.doc.stone_details.forEach(row => {
//         if (frm.doc.chemical !== undefined) row.chemical = frm.doc.chemical;
//         if (frm.doc.dry_fitting !== undefined) row.dry_fitting = frm.doc.dry_fitting;
//         if (frm.doc.polishing !== undefined) row.polishing = frm.doc.polishing;
//     });
//     frm.refresh_field("stone_details");
// }

// // --- Restrict Sub Part based on Main Part ---
// frappe.ui.form.on("Size List", {
//     main_part: function(frm) {
//         frm.set_query("sub_part", function() {
//             if (!frm.doc.main_part) {
//                 frappe.throw(__("Please select Main Part before choosing a Sub Part."));
//             }
//             return {
//                 filters: {
//                     main_part: frm.doc.main_part
//                 }
//             };
//         });

//         // clear sub_part if mismatch
//         if (frm.doc.sub_part) {
//             frappe.db.get_value("Sub Part", frm.doc.sub_part, "main_part", function(r) {
//                 if (r && r.main_part !== frm.doc.main_part) {
//                     frm.set_value("sub_part", null);
//                 }
//             });
//         }
//     },

//     validate: function(frm) {
//         if (!frm.doc.main_part && frm.doc.sub_part) {
//             frappe.throw(__("You cannot add a Sub Part without selecting a Main Part."));
//         }
//     }
// });

// //size list data -------------------------------------
// frappe.ui.form.on("Size List Details", {
//     stone_name: function(frm, cdt, cdn) {
//         let row = locals[cdt][cdn];
//         if (row.stone_name) {
//             frappe.db.get_value("Stone Name", row.stone_name, "stone_code", (r) => {
//                 if (r && r.stone_code) {
//                     row.stone_code = r.stone_code;
//                     frm.refresh_field("stone_details");  // child table fieldname
//                 }
//             });
//         }
//     }
// });


// //-------------------------------------------------------------------------------------------------------------------------------   
// frappe.ui.form.on('Size List', {
//     refresh: function(frm) {
//         setup_buttons(frm);
//         attach_render_listener(frm);
//         schedule_apply_styles(frm);
//     },

//     after_save: function(frm) {
//         schedule_apply_styles(frm);
//     }
// });

// function setup_buttons(frm) {
//     // store refs on frm to avoid removing unknown things
//     frm._szlst_buttons = frm._szlst_buttons || {};

//     let unapproved = (frm.doc.stone_details || []).filter(r => !r.is_approved);
//     // Approve Selected Rows
//     if (!frm._szlst_buttons.approve && unapproved.length > 0) {
//         frm._szlst_buttons.approve = frm.add_custom_button(__('Approve Selected Rows'), () => {
//             approve_selected_rows(frm);
//         });
//         frm._szlst_buttons.approve.addClass('btn-primary');
//     }

//     // Publish (placed under Actions)
//     if (!frm._szlst_buttons.publish) {
//         frm._szlst_buttons.publish = frm.add_custom_button(__('Publish'), () => {
//             publish_data(frm);
//         }, __('Actions'));
//         frm._szlst_buttons.publish.addClass('btn-success');
//     }

//     // enable/disable Publish depending on all-approved
//     try {
//         let allApproved = (frm.doc.stone_details || []).length > 0 &&
//                           (frm.doc.stone_details || []).every(r => r.is_approved);
//         if (frm._szlst_buttons.publish) {
//             frm._szlst_buttons.publish.prop('disabled', !allApproved);
//         }
//     } catch (e) {
//         console.error('publish btn enable/disable error', e);
//     }
// }

// function approve_selected_rows(frm) {
//     const grid = frm.fields_dict.stone_details && frm.fields_dict.stone_details.grid;
//     const selected = grid ? grid.get_selected_children() : [];
//     if (!selected.length) {
//         frappe.msgprint(__('Please select at least one row to approve.'));
//         return;
//     }

//     let count = 0;
//     selected.forEach(row => {
//         if (!row.is_approved) {
//             frappe.model.set_value(row.doctype, row.name, 'is_approved', 1);
//             count++;
//         }
//     });

//     if (count === 0) {
//         frappe.msgprint(__('All selected rows are already approved.'));
//         return;
//     }

//     // Wait a little, then refresh and reapply
//     setTimeout(() => {
//         frm.refresh_field('stone_details');
//         schedule_apply_styles(frm);
//         frm.refresh(); // update buttons
//         frappe.show_alert(__('{0} row(s) approved and locked.', [count]), 'green');
//     }, 300);
// }

// function publish_data(frm) {
//     frappe.call({
//         method: 'frappe.client.set_value',
//         args: {
//             doctype: frm.doctype,
//             name: frm.docname,
//             fieldname: 'status',
//             value: 'Published'
//         },
//         callback: function(r) {
//             if (r.message) {
//                 frm.reload_doc();
//                 frappe.show_alert(__('Document published!'), 'green');
//             }
//         }
//     });
// }

// // Apply row UI changes for approved rows (safe & tolerant)
// function apply_row_styles(frm) {
//     const child_table_fieldname = 'stone_details';
//     const grid_wrapper = frm.fields_dict[child_table_fieldname] && frm.fields_dict[child_table_fieldname].grid && frm.fields_dict[child_table_fieldname].grid.wrapper;
//     const grid = frm.fields_dict[child_table_fieldname] && frm.fields_dict[child_table_fieldname].grid;

//     if (!frm.doc[child_table_fieldname] || !grid_wrapper) return;

//     frm.doc[child_table_fieldname].forEach(row => {
//         try {
//             // robust row lookup (grid_rows_by_docname OR DOM search by data-name)
//             let grid_row_obj = grid && grid.grid_rows_by_docname && grid.grid_rows_by_docname[row.name];
//             let $row = null;

//             if (grid_row_obj && grid_row_obj.row) {
//                 $row = grid_row_obj.row;
//             } else {
//                 // fallback DOM selector
//                 $row = grid_wrapper.find(`.grid-row[data-name="${row.name}"]`);
//                 if (!$row.length) {
//                     $row = grid_wrapper.find(`[data-name="${row.name}"]`);
//                 }
//             }

//             if (!$row || !$row.length) {
//                 // not rendered yet - skip
//                 return;
//             }

//             process_row($row, row.is_approved);
//         } catch (e) {
//             console.error('apply_row_styles row error', e);
//         }
//     });
// }

// function process_row($row, is_approved) {
//     if (is_approved) {
//         // apply grey look
//         $row.addClass('approved-row').css('background-color', '#f7f7f7');

//         // disable input elements inside row but allow clicks on action controls
//         $row.find('input, select, textarea, .input-with-feedback')
//             .prop('readonly', true)
//             .prop('disabled', true)
//             .css({
//                 'background-color': '#fafafa',
//                 'color': '#666',
//                 'border-color': '#eee',
//                 'cursor': 'not-allowed'
//             }).attr('title', 'Approved - Locked');

//         $row.find('input[type="checkbox"]').prop('disabled', true);

//         // hide edit/delete if present
//         $row.find('.grid-edit-row, .grid-delete-row').hide();

//         // prevent opening the edit dialog when clicking empty cell area,
//         // but allow clicks on buttons/inputs/links inside the row
//         $row.off('.approvalClick').on('click.approvalClick', function(e) {
//             // if the click target is an actionable control, allow it
//             if ($(e.target).closest('button, a, input, select, textarea, .grid-edit-row, .grid-delete-row, .grid-row-check').length) {
//                 return;
//             }
//             e.preventDefault();
//             e.stopPropagation();
//             return false;
//         });

//         // block enter/tab from triggering row-level behavior unless focused into a control
//         $row.off('.approvalKey').on('keydown.approvalKey', function(e) {
//             if ($(e.target).is('input, textarea, select') || $(e.target).closest('button, a, .grid-edit-row').length) {
//                 return;
//             }
//             if (e.key === 'Enter' || e.key === 'Tab') {
//                 e.preventDefault();
//                 e.stopPropagation();
//             }
//         });

//         // disable right-click on the non-interactive area
//         $row.off('.approvalCtx').on('contextmenu.approvalCtx', function(e) {
//             if ($(e.target).closest('button, input, a, .grid-edit-row, .grid-delete-row').length) {
//                 return; // allow contextmenu on controls
//             }
//             e.preventDefault();
//             return false;
//         });

//     } else {
//         // revert to normal
//         $row.removeClass('approved-row').css('background-color', '');
//         $row.find('input, select, textarea, .input-with-feedback')
//             .prop('readonly', false)
//             .prop('disabled', false)
//             .css({
//                 'background-color': '',
//                 'color': '',
//                 'border-color': '',
//                 'cursor': ''
//             }).removeAttr('title');
//         $RowCheckboxes = $row.find('input[type="checkbox"]').prop('disabled', false);
//         $row.find('.grid-edit-row, .grid-delete-row').show();
//         $row.off('.approvalClick .approvalKey .approvalCtx');
//     }
// }

// function attach_render_listener(frm) {
//     const child_field = 'stone_details';
//     const wrapper = frm.fields_dict[child_field] && frm.fields_dict[child_field].grid && frm.fields_dict[child_field].grid.wrapper;
//     if (!wrapper) return;

//     // remove previous listener safely
//     wrapper.off('render_complete.size_approval');

//     // attach listener - when grid renders, re-apply styles (with a tiny debounce)
//     wrapper.on('render_complete.size_approval', function() {
//         // small delay to allow DOM to settle
//         frappe.after_ajax(() => {
//             setTimeout(() => {
//                 apply_row_styles(frm);
//             }, 80);
//         });
//     });
// }

// // a lightweight retry scheduler for initial rendering
// function schedule_apply_styles(frm) {
//     let tries = 0;
//     const handle = setInterval(() => {
//         try {
//             apply_row_styles(frm);
//         } catch (e) {
//             console.error('schedule_apply error', e);
//         }
//         tries++;
//         if (tries > 12) clearInterval(handle); // give it a few tries (~2.4s)
//     }, 200);
// }

// // inject small CSS once
// if (!$('#approval-style').length) {
//     $(`<style id="approval-style">
//         .approved-row { background-color: #f7f7f7 !important; }
//         .approved-row .grid-static-col { background-color: #eee !important; }
//     </style>`).appendTo('head');
// }



// // ------------------------------------------------------------
// // -------------------------- new change -------------------------------
// // ------------------------------------------------------------


// Size List client script - consolidated and cleaned

// ----------------------------
// Child Doctype: Size List Details
// ----------------------------
frappe.ui.form.on('Size List Details', {
    stone_name: function(frm, cdt, cdn) {
        let row = locals[cdt][cdn];
        if (!row) return;
        if (row.stone_name) {
            frappe.db.get_value('Stone Name', row.stone_name, 'stone_code', (r) => {
                if (r && r.stone_code) {
                    frappe.model.set_value(cdt, cdn, 'stone_code', r.stone_code);
                }
            });
        }
    },

    range: function(frm, cdt, cdn) {
        let row = locals[cdt][cdn];
        if (!row || !row.range) return;

        let input = row.range.toString().trim();
        if (!input) return;

        // Disallow mixing comma + dash
        if (input.indexOf('-') !== -1 && input.indexOf(',') !== -1) {
            frappe.show_alert({message: __('Invalid input → You cannot mix ranges and comma values'), indicator: 'red'});
            frappe.model.set_value(cdt, cdn, 'range', '');
            return;
        }

        // Parse numbers
        let numbers = [];
        if (input.indexOf('-') !== -1) {
            let parts = input.split('-').map(s => s.trim());
            let start = cint(parts[0]), end = cint(parts[1]);
            if (isNaN(start) || isNaN(end) || start > end) {
                frappe.show_alert({message: __('Invalid range → ') + input, indicator: 'red'});
                return;
            }
            for (let i = start; i <= end; i++) numbers.push(i);
        } else if (input.indexOf(',') !== -1) {
            numbers = input.split(',').map(s => cint(s.trim())).filter(n => !isNaN(n));
        } else {
            let n = cint(input);
            if (!isNaN(n)) numbers = [n];
        }

        numbers = [...new Set(numbers)].sort((a,b) => a-b);
        if (!numbers.length) return;

        // Require stone_code on the first row
        if (!row.stone_code) {
            frappe.show_alert({message: __('Please enter Stone Code in the first row before using range'), indicator: 'red'});
            return;
        }

        // // Extract prefix and numeric width safely
        // let m = (row.stone_code || '').toString().match(/^(.*?)(\d+)$/);
        // if (!m) {
        //     frappe.show_alert({message: __('Stone Code must end with numbers, e.g. ABCDE001'), indicator: 'red'});
        //     return;
        // }
        let prefix = m[1];
        let num_width = m[2].length;

        // Clear range field for cleanliness
        frappe.model.set_value(cdt, cdn, 'range', '');

        let duplicate_codes = [];
        numbers.forEach((n, idx) => {
            let stone_code = prefix + String(n).padStart(num_width, '0');
            let exists = (frm.doc.stone_details || []).some(r => r.stone_code === stone_code || r.serial_no === n);
            if (exists) {
                duplicate_codes.push(stone_code);
                return;
            }

            if (idx === 0) {
                row.stone_code = stone_code;
                row.serial_no = n;
                frappe.model.set_value(cdt, cdn, 'stone_code', stone_code);
                frappe.model.set_value(cdt, cdn, 'serial_no', n);
            } else {
                let nr = frm.add_child('stone_details');
                // copy a subset of fields
                ['stone_name','chemical','dry_fitting','polishing'].forEach(f => {
                    if (row[f] !== undefined) nr[f] = row[f];
                });
                nr.stone_code = stone_code;
                nr.serial_no = n;
                frappe.model.set_value(nr.doctype, nr.name, 'stone_code', stone_code);
                frappe.model.set_value(nr.doctype, nr.name, 'serial_no', n);
            }
        });

        if (duplicate_codes.length) {
            frappe.show_alert({message: __('Skipped duplicates: ') + duplicate_codes.join(', '), indicator: 'orange'});
        }

        frm.refresh_field('stone_details');
    },

    stone_code: function(frm, cdt, cdn) {
        let row = locals[cdt][cdn];
        if (!row || !row.stone_code) return;

        // Safely parse
        // let m = (row.stone_code || '').toString().match(/^(.*?)(\d+)$/);
        // if (!m) {
        //     frappe.msgprint(__('Stone Code must end with numbers, e.g. ABCDE001'));
        //     return;
        // }

        let prefix = m[1];
        let base_num = cint(m[2]);
        let num_width = m[2].length;
        let next_num = base_num + 1;

        let all = frm.doc.stone_details || [];
        let startIndex = all.findIndex(r => r.name === row.name);
        if (startIndex === -1) return;

        let existing = new Set(all.filter(r => r.stone_code).map(r => r.stone_code));
        let duplicate_codes = [];

        for (let i = startIndex + 1; i < all.length; i++) {
            let r = all[i];
            if (r.stone_code) {
                let mm = (r.stone_code || '').toString().match(/^(.*?)(\d+)$/);
                if (mm && mm[1] === prefix) {
                    next_num = cint(mm[2]) + 1;
                }
                break;
            }

            let generated = prefix + String(next_num++).padStart(num_width, '0');
            if (existing.has(generated)) {
                duplicate_codes.push(generated);
                continue;
            }
            frappe.model.set_value(r.doctype, r.name, 'stone_code', generated);
            existing.add(generated);
        }

        frm.refresh_field('stone_details');
        update_total_volume(frm);

        if (duplicate_codes.length) {
            frappe.show_alert({message: __('Warning: Duplicate Stone Codes detected → ') + duplicate_codes.join(', '), indicator: 'orange'});
        }
    },

    l1: calculate_volume,
    l2: function(frm, cdt, cdn) {
        let row = locals[cdt][cdn];
        if (row && row.l2 >= 12) {
            frappe.msgprint(__('L2 must be less than 12 inches'));
            frappe.model.set_value(cdt, cdn, 'l2', 0);
        }
        calculate_volume(frm, cdt, cdn);
    },
    b1: calculate_volume,
    b2: function(frm, cdt, cdn) {
        let row = locals[cdt][cdn];
        if (row && row.b2 >= 12) {
            frappe.msgprint(__('B2 must be less than 12 inches'));
            frappe.model.set_value(cdt, cdn, 'b2', 0);
        }
        calculate_volume(frm, cdt, cdn);
    },
    h1: calculate_volume,
    h2: function(frm, cdt, cdn) {
        let row = locals[cdt][cdn];
        if (row && row.h2 >= 12) {
            frappe.msgprint(__('H2 must be less than 12 inches'));
            frappe.model.set_value(cdt, cdn, 'h2', 0);
        }
        calculate_volume(frm, cdt, cdn);
    },

    stone_details_remove: function(frm) {
        update_total_volume(frm);
    }
});

// --- Volume calculation for a single row ---
function calculate_volume(frm, cdt, cdn) {
    let row = locals[cdt][cdn];
    if (!row) return;
    let L = ((row.l1 || 0) * 12) + (row.l2 || 0);
    let B = ((row.b1 || 0) * 12) + (row.b2 || 0);
    let H = ((row.h1 || 0) * 12) + (row.h2 || 0);
    row.volume = ((L * B * H) / 1728).toFixed(2);
    frm.refresh_field('stone_details');
    update_total_volume(frm);
}

// --- Total volume across all rows ---
function update_total_volume(frm) {
    let total = 0;
    (frm.doc.stone_details || []).forEach(r => {
        total += flt(r.volume);
    });
    frm.set_value('total_volume', total.toFixed(2));
}

// ============================
// Parent Doctype: Size List
// ============================
frappe.ui.form.on('Size List', {
    refresh: function(frm) {
        if (frm.doc.baps_project) {
            load_project_flags(frm);
        }
        setup_buttons(frm);
        attach_render_listener(frm);
        schedule_apply_styles(frm);
    },

    validate: function(frm) {
        let unapproved = (frm.doc.stone_details || []).filter(r => !r.is_approved);
        if (unapproved.length > 0) {
            frappe.validated = false;  // prevent form submission
            frappe.warn(
                __("Not All Rows Approved"),
                __("You are submitting this form with {0} unapproved rows. Are you sure you want to continue?", [unapproved.length]),
                () => {
                    frappe.validated = true;  // allow submission
                    frm.save();
                },
                __("Proceed Anyway"),
                true  // is_minimizable
            );
            return false;
        }
        return true;
    },

    after_save: function(frm) {
        schedule_apply_styles(frm);
    },

    baps_project: function(frm) {
        if (frm.doc.baps_project) {
            load_project_flags(frm);
        } else {
            frm.set_value({chemical: 0, dry_fitting: 0, polishing: 0});
            sync_child_process_flags(frm);
        }
    },

    stone_details_add: function(frm, cdt, cdn) {
        let row = locals[cdt][cdn];
        if (!row) return;
        if (frm.doc.chemical !== undefined) frappe.model.set_value(cdt, cdn, 'chemical', frm.doc.chemical);
        if (frm.doc.dry_fitting !== undefined) frappe.model.set_value(cdt, cdn, 'dry_fitting', frm.doc.dry_fitting);
        if (frm.doc.polishing !== undefined) frappe.model.set_value(cdt, cdn, 'polishing', frm.doc.polishing);
    },

    chemical: function(frm) { sync_child_process_flags(frm); },
    dry_fitting: function(frm) { sync_child_process_flags(frm); },
    polishing: function(frm) { sync_child_process_flags(frm); }
});

function load_project_flags(frm) {
    if (!frm.doc.baps_project) return;
    frappe.db.get_doc('Baps Project', frm.doc.baps_project).then(project => {
        frm.set_value({
            chemical: project.chemical ? 1 : 0,
            dry_fitting: project.dry_fitting ? 1 : 0,
            polishing: project.polishing ? 1 : 0
        });
        sync_child_process_flags(frm);
    });
}

function sync_child_process_flags(frm) {
    if (!frm.doc.stone_details) return;
    frm.doc.stone_details.forEach(row => {
        if (frm.doc.chemical !== undefined) row.chemical = frm.doc.chemical;
        if (frm.doc.dry_fitting !== undefined) row.dry_fitting = frm.doc.dry_fitting;
        if (frm.doc.polishing !== undefined) row.polishing = frm.doc.polishing;
    });
    frm.refresh_field('stone_details');
}

// --- Approval & Publish UI ---
function setup_buttons(frm) {
    // Remove existing buttons to prevent duplicates
    if (frm.custom_buttons['Approve Selected Rows']) {
        frm.custom_buttons['Approve Selected Rows'].remove();
        delete frm.custom_buttons['Approve Selected Rows'];
    }
    if (frm.custom_buttons['Publish']) {
        frm.custom_buttons['Publish'].remove();
        delete frm.custom_buttons['Publish'];
    }

    let unapproved = (frm.doc.stone_details || []).filter(r => !r.is_approved);
    if (unapproved.length) {
        frm.add_custom_button(__('Approve Selected Rows'), () => approve_selected_rows(frm))
            .addClass('btn-primary');
    }

    let publishBtn = frm.add_custom_button(__('Publish'), () => publish_data(frm), __('Actions'))
        .addClass('btn-success');

    // Enable/disable based on approval status
    let allApproved = (frm.doc.stone_details || []).length > 0 && 
                      (frm.doc.stone_details || []).every(r => r.is_approved);
    publishBtn.prop('disabled', !allApproved);
}

function approve_selected_rows(frm) {
    const grid = frm.fields_dict.stone_details && frm.fields_dict.stone_details.grid;
    if (!grid || !grid.get_selected_children) {
        frappe.msgprint(__('Grid not ready'));
        return;
    }

    const selected = grid.get_selected_children();
    if (!selected.length) {
        frappe.msgprint(__('Please select at least one row to approve.'));
        return;
    }

    let updates = [];
    selected.forEach(r => {
        if (!r.is_approved) {
            updates.push(
                frappe.db.set_value(r.doctype, r.name, 'is_approved', 1)
                    .then(() => {
                        // Update local state after server success
                        r.is_approved = 1;
                        frappe.model.set_value(r.doctype, r.name, 'is_approved', 1);
                    })
            );
        }
    });

    if (!updates.length) {
        frappe.msgprint(__('All selected rows are already approved.'));
        return;
    }

    Promise.all(updates)
        .then(() => {
            frm.reload_doc();
            schedule_apply_styles(frm);
            frappe.show_alert({
                message: __('{0} row(s) approved and locked.', [updates.length]),
                indicator: 'green'
            });
        })
        .catch(err => {
            console.error('Error approving rows:', err);
            frappe.msgprint(__('Error while approving rows. See console for details.'));
        });
}

function publish_data(frm) {
    frappe.call({
        method: 'frappe.client.set_value',
        args: {
            doctype: frm.doctype,
            name: frm.docname,
            fieldname: 'status',
            value: 'Published'
        },
        callback: function(r) {
            if (r.message) {
                frm.reload_doc();
                frappe.show_alert({
                    message: __('Document published successfully!'),
                    indicator: 'green'
                });
            }
        }
    });
}

// --- Row styling & locking ---
function apply_row_styles(frm) {
    if (!frm.doc.stone_details || !frm.fields_dict.stone_details) return;

    const grid = frm.fields_dict.stone_details.grid;
    const wrapper = grid && grid.wrapper;
    if (!wrapper) return;

    frm.doc.stone_details.forEach(row => {
        try {
            let grid_row = grid.grid_rows_by_docname[row.name];
            if (!grid_row || !grid_row.row) return;
            
            let $row = grid_row.row;
            if (!$row.length) return;

            process_row($row, row.is_approved);
        } catch (e) {
            console.error('Error applying row styles:', e);
        }
    });
}

function process_row($row, is_approved) {
    if (is_approved) {
        $row.addClass('approved-row');
        
        // Disable all inputs
        $row.find('input, select, textarea, .input-with-feedback')
            .prop('readonly', true)
            .prop('disabled', true)
            .css({
                'background-color': '#f9f9f9',
                'color': '#666',
                'border-color': '#ddd',
                'cursor': 'not-allowed'
            })
            .attr('title', 'Approved - Locked');

        $row.find('input[type="checkbox"]').prop('disabled', true);
        
        // Hide edit/delete buttons
        $row.find('.grid-row-edit, .grid-row-delete, .grid-row-duplicate').hide();

        // Block row interactions except for checkboxes
        $row.off('.approval')
            .on('click.approval', function(e) {
                const $target = $(e.target);
                if (!$target.closest('input[type="checkbox"], .grid-row-check').length) {
                    e.stopPropagation();
                    return false;
                }
            });

    } else {
        $row.removeClass('approved-row');
        
        // Re-enable all inputs
        $row.find('input, select, textarea, .input-with-feedback')
            .prop('readonly', false)
            .prop('disabled', false)
            .css({
                'background-color': '',
                'color': '',
                'border-color': '',
                'cursor': ''
            })
            .removeAttr('title');

        $row.find('input[type="checkbox"]').prop('disabled', false);
        
        // Show edit/delete buttons
        $row.find('.grid-row-edit, .grid-row-delete, .grid-row-duplicate').show();

        // Remove approval handlers
        $row.off('.approval');
    }
}

function attach_render_listener(frm) {
    const wrapper = frm.fields_dict.stone_details.grid.wrapper;
    
    // Remove old listener
    wrapper.off('render_complete.size_approval');
    
    // Add new listener with debounce
    wrapper.on('render_complete.size_approval', () => {
        frappe.after_ajax(() => setTimeout(() => apply_row_styles(frm), 100));
    });
}

function schedule_apply_styles(frm) {
    let tries = 0;
    const handle = setInterval(() => {
        try {
            apply_row_styles(frm);
        } catch (e) {
            console.error('Error in schedule_apply_styles:', e);
        }
        if (++tries >= 10) clearInterval(handle);
    }, 200);
}

// Inject CSS
if (!$('#size-list-style').length) {
    $(`<style id="size-list-style">
        .approved-row {
            background-color: #f0f0f0 !important;
        }
        .approved-row .grid-static-col {
            background-color: #e8e8e8 !important;
        }
        .approved-row .editable-row {
            background-color: #f5f5f5 !important;
        }
        .approved-row .grid-row-check {
            opacity: 0.7;
        }
    </style>`).appendTo('head');
}




////--------------------------------------------------------------------------------------------------------------------------------------------------------------------




new change


///---------------------------------------------------------------------------------------------------------------------------------------------------------------------



// ============================
// Size List - Field-Level Approval System with Persistent Storage
// ============================

// Child Table Handler - Size List Details
frappe.ui.form.on('Size List Details', {
    // Stone Name handler with approval check
    stone_name: function(frm, cdt, cdn) {
        let row = locals[cdt][cdn];
        if (is_field_approved(frm, row, 'stone_name')) {
            frappe.show_alert({message: __('Stone Name is approved and locked'), indicator: 'red'});
            // Reset the field to previous value
            setTimeout(() => {
                let previous_value = get_previous_field_value(frm, row, 'stone_name');
                frappe.model.set_value(cdt, cdn, 'stone_name', previous_value);
                
                // Also force gray styling for the entire row
                let row_index = row.idx - 1;
                force_row_gray_styling(row_index);
            }, 100);
            return false;
        }
        // Save current value for future reference
        save_previous_field_value(frm, row, 'stone_name', row.stone_name);
        
        // Original stone_name logic
        if (row && row.stone_name) {
            frappe.db.get_value('Stone Name', row.stone_name, 'stone_code', (r) => {
                if (r && r.stone_code) {
                    frappe.model.set_value(cdt, cdn, 'stone_code', r.stone_code);
                }
            });
        }
        setTimeout(() => setup_approval_and_publish_buttons(frm), 100);
    },

    stone_code: function(frm, cdt, cdn) {
        let row = locals[cdt][cdn];
        if (is_field_approved(frm, row, 'stone_code')) {
            frappe.show_alert({message: __('Stone Code is approved and locked'), indicator: 'red'});
            // Reset the field to previous value
            setTimeout(() => {
                let previous_value = get_previous_field_value(frm, row, 'stone_code');
                frappe.model.set_value(cdt, cdn, 'stone_code', previous_value);
            }, 100);
            return false;
        }
        // Save current value for future reference
        save_previous_field_value(frm, row, 'stone_code', row.stone_code);
        setTimeout(() => setup_approval_and_publish_buttons(frm), 100);
    },

    // Dimension fields with approval checks
    l1: function(frm, cdt, cdn) { 
        let row = locals[cdt][cdn];
        if (is_field_approved(frm, row, 'l1')) {
            frappe.show_alert({message: __('L1 field is approved and locked'), indicator: 'red'});
            // Reset the field to previous value
            setTimeout(() => {
                let previous_value = get_previous_field_value(frm, row, 'l1');
                frappe.model.set_value(cdt, cdn, 'l1', previous_value);
            }, 100);
            return false;
        }
        // Save current value for future reference
        save_previous_field_value(frm, row, 'l1', row.l1);
        calculate_volume(frm, cdt, cdn); 
        setTimeout(() => setup_approval_and_publish_buttons(frm), 100);
    },
    
    l2: function(frm, cdt, cdn) {
        let row = locals[cdt][cdn];
        if (is_field_approved(frm, row, 'l2')) {
            frappe.show_alert({message: __('L2 field is approved and locked'), indicator: 'red'});
            // Reset the field to previous value
            setTimeout(() => {
                let previous_value = get_previous_field_value(frm, row, 'l2');
                frappe.model.set_value(cdt, cdn, 'l2', previous_value);
            }, 100);
            return false;
        }
        // Save current value for future reference
        save_previous_field_value(frm, row, 'l2', row.l2);
        if (row && row.l2 >= 12) {
            frappe.msgprint(__('L2 must be less than 12 inches'));
            frappe.model.set_value(cdt, cdn, 'l2', 0);
        }
        calculate_volume(frm, cdt, cdn);
        setTimeout(() => setup_approval_and_publish_buttons(frm), 100);
    },
    
    b1: function(frm, cdt, cdn) { 
        let row = locals[cdt][cdn];
        if (is_field_approved(frm, row, 'b1')) {
            frappe.show_alert({message: __('B1 field is approved and locked'), indicator: 'red'});
            // Reset the field to previous value
            setTimeout(() => {
                let previous_value = get_previous_field_value(frm, row, 'b1');
                frappe.model.set_value(cdt, cdn, 'b1', previous_value);
            }, 100);
            return false;
        }
        // Save current value for future reference
        save_previous_field_value(frm, row, 'b1', row.b1);
        calculate_volume(frm, cdt, cdn); 
        setTimeout(() => setup_approval_and_publish_buttons(frm), 100);
    },
    
    b2: function(frm, cdt, cdn) {
        let row = locals[cdt][cdn];
        if (is_field_approved(frm, row, 'b2')) {
            frappe.show_alert({message: __('B2 field is approved and locked'), indicator: 'red'});
            // Reset the field to previous value
            setTimeout(() => {
                let previous_value = get_previous_field_value(frm, row, 'b2');
                frappe.model.set_value(cdt, cdn, 'b2', previous_value);
            }, 100);
            return false;
        }
        // Save current value for future reference
        save_previous_field_value(frm, row, 'b2', row.b2);
        if (row && row.b2 >= 12) {
            frappe.msgprint(__('B2 must be less than 12 inches'));
            frappe.model.set_value(cdt, cdn, 'b2', 0);
        }
        calculate_volume(frm, cdt, cdn);
        setTimeout(() => setup_approval_and_publish_buttons(frm), 100);
    },
    
    h1: function(frm, cdt, cdn) { 
        let row = locals[cdt][cdn];
        if (is_field_approved(frm, row, 'h1')) {
            frappe.show_alert({message: __('H1 field is approved and locked'), indicator: 'red'});
            // Reset the field to previous value
            setTimeout(() => {
                let previous_value = get_previous_field_value(frm, row, 'h1');
                frappe.model.set_value(cdt, cdn, 'h1', previous_value);
            }, 100);
            return false;
        }
        // Save current value for future reference
        save_previous_field_value(frm, row, 'h1', row.h1);
        calculate_volume(frm, cdt, cdn); 
        setTimeout(() => setup_approval_and_publish_buttons(frm), 100);
    },
    
    h2: function(frm, cdt, cdn) {
        let row = locals[cdt][cdn];
        if (is_field_approved(frm, row, 'h2')) {
            frappe.show_alert({message: __('H2 field is approved and locked'), indicator: 'red'});
            // Reset the field to previous value
            setTimeout(() => {
                let previous_value = get_previous_field_value(frm, row, 'h2');
                frappe.model.set_value(cdt, cdn, 'h2', previous_value);
            }, 100);
            return false;
        }
        // Save current value for future reference
        save_previous_field_value(frm, row, 'h2', row.h2);
        if (row && row.h2 >= 12) {
            frappe.msgprint(__('H2 must be less than 12 inches'));
            frappe.model.set_value(cdt, cdn, 'h2', 0);
        }
        calculate_volume(frm, cdt, cdn);
        setTimeout(() => setup_approval_and_publish_buttons(frm), 100);
    },

    stone_details_remove: function(frm) {
        update_total_volume(frm);
        setTimeout(() => setup_approval_and_publish_buttons(frm), 100);
    }
});

// Parent Form Handler - Size List
frappe.ui.form.on('Size List', {
    refresh: function(frm) {
        setup_approval_and_publish_buttons(frm);
        
        // Restore approval states from saved data
        restore_approval_states(frm);
        
        // Initialize previous field values for all rows
        initialize_previous_field_values(frm);
        
        // Apply field-level approval styling when form loads
        setTimeout(() => {
            apply_all_field_approval_states(frm);
            // Debug approval states (temporary)
            debug_approval_states(frm);
        }, 800);
        
        // Load project flags if baps_project is selected
        if (frm.doc.baps_project) {
            load_project_flags(frm);
        }
    },

    baps_project: function(frm) {
        if (frm.doc.baps_project) {
            load_project_flags(frm);
        } else {
            frm._project_flags = { chemical: 0, dry_fitting: 0, polishing: 0 };
            set_child_grid_readonly(frm);
        }
    },
    
    main_part: function(frm) {
        if (!frm.doc.main_part) frm.set_value('sub_part', '');
        
        frm.set_query("sub_part", function() {
            if (!frm.doc.main_part) {
                frappe.throw("Please select Main Part before choosing a Sub Part.");
            }
            return {
                filters: {
                    main_part: frm.doc.main_part
                }
            };
        });

        // clear sub_part if mismatch
        if (frm.doc.sub_part) {
            frappe.db.get_value("Sub Part", frm.doc.sub_part, "main_part", function(r) {
                if (r && r.main_part !== frm.doc.main_part) {
                    frm.set_value("sub_part", null);
                }
            });
        }
    },
    
    sub_part: function(frm) {
        if (!frm.doc.sub_part) frm.set_value('main_part', '');
    },
    
    stone_details_add: function(frm, cdt, cdn) {
        let row = locals[cdt][cdn];
        if (frm._project_flags?.chemical) frappe.model.set_value(cdt, cdn, 'chemical', 1);
        if (frm._project_flags?.dry_fitting) frappe.model.set_value(cdt, cdn, 'dry_fitting', 1);
        if (frm._project_flags?.polishing) frappe.model.set_value(cdt, cdn, 'polishing', 1);
    },
    
    validate: function(frm) {
        if (!frm.doc.main_part && frm.doc.sub_part) {
            frappe.throw("You cannot add a Sub Part without selecting a Main Part.");
        }
    }
});

// ============================
// PERSISTENT STORAGE FUNCTIONS (Browser localStorage)
// ============================

// Get unique key for this document's approval data
function get_approval_storage_key(frm) {
    return `size_list_approvals_${frm.doc.name || 'new'}`;
}

// Check if a field is approved (with persistent storage)
function is_field_approved(frm, row, field_name) {
    try {
        let storage_key = get_approval_storage_key(frm);
        let approval_data = localStorage.getItem(storage_key);
        if (!approval_data) return false;
        
        approval_data = JSON.parse(approval_data);
        return !!(approval_data[row.name] && approval_data[row.name][field_name]);
    } catch (e) {
        console.error('Error checking field approval state:', e);
        return false;
    }
}

// Save approval state to localStorage
function save_approval_state(frm, row_name, field_name, is_approved) {
    try {
        let storage_key = get_approval_storage_key(frm);
        let approval_data = {};
        
        // Load existing approval data
        let existing_data = localStorage.getItem(storage_key);
        if (existing_data) {
            approval_data = JSON.parse(existing_data);
        }
        
        // Initialize row data if not exists
        if (!approval_data[row_name]) {
            approval_data[row_name] = {};
        }
        
        // Set approval state
        approval_data[row_name][field_name] = is_approved;
        
        // Save back to localStorage
        localStorage.setItem(storage_key, JSON.stringify(approval_data));
    } catch (e) {
        console.error('Error saving approval state:', e);
    }
}

// Restore approval states from localStorage
function restore_approval_states(frm) {
    if (!frm.doc.stone_details) return;
    
    try {
        let storage_key = get_approval_storage_key(frm);
        let approval_data = localStorage.getItem(storage_key);
        if (!approval_data) return;
        
        approval_data = JSON.parse(approval_data);
        
        frm.doc.stone_details.forEach(row => {
            if (approval_data[row.name]) {
                // Restore client-side approval data for immediate use
                row._approved_fields = approval_data[row.name];
            }
        });
    } catch (e) {
        console.error('Error restoring approval states:', e);
    }
}

// Helper functions for field value management
function save_previous_field_value(frm, row, field_name, value) {
    try {
        let storage_key = `${get_approval_storage_key(frm)}_previous_values`;
        let previous_data = {};
        
        // Load existing previous value data
        let existing_data = localStorage.getItem(storage_key);
        if (existing_data) {
            previous_data = JSON.parse(existing_data);
        }
        
        // Initialize row data if not exists
        if (!previous_data[row.name]) {
            previous_data[row.name] = {};
        }
        
        // Set previous value
        previous_data[row.name][field_name] = value;
        
        // Save back to localStorage
        localStorage.setItem(storage_key, JSON.stringify(previous_data));
    } catch (e) {
        console.error('Error saving previous field value:', e);
    }
}

function get_previous_field_value(frm, row, field_name) {
    try {
        let storage_key = `${get_approval_storage_key(frm)}_previous_values`;
        let previous_data = localStorage.getItem(storage_key);
        if (!previous_data) return null;
        
        previous_data = JSON.parse(previous_data);
        return previous_data[row.name] && previous_data[row.name][field_name] || null;
    } catch (e) {
        console.error('Error getting previous field value:', e);
        return null;
    }
}

// Initialize previous field values for all rows
function initialize_previous_field_values(frm) {
    if (!frm.doc.stone_details) return;
    
    let required_fields = ['stone_name', 'stone_code', 'l1', 'b1', 'h1', 'l2', 'b2', 'h2', 'volume'];
    
    frm.doc.stone_details.forEach(row => {
        required_fields.forEach(field => {
            if (row[field] !== undefined && row[field] !== null) {
                save_previous_field_value(frm, row, field, row[field]);
            }
        });
    });
}

// Debug function to check approval states
function debug_approval_states(frm) {
    console.log('=== Approval States Debug ===');
    if (!frm.doc.stone_details) {
        console.log('No stone_details found');
        return;
    }
    
    frm.doc.stone_details.forEach((row, index) => {
        console.log(`Row ${index + 1} (${row.name}):`);
        let required_fields = ['stone_name', 'stone_code', 'l1', 'b1', 'h1', 'l2', 'b2', 'h2', 'volume'];
        required_fields.forEach(field => {
            let isApproved = is_field_approved(frm, row, field);
            let value = row[field];
            console.log(`  ${field}: ${value} (approved: ${isApproved})`);
        });
    });
    
    // Also check localStorage
    let storage_key = get_approval_storage_key(frm);
    let approval_data = localStorage.getItem(storage_key);
    console.log('LocalStorage data:', approval_data ? JSON.parse(approval_data) : 'None');
}

// ============================
// CORE FUNCTIONS
// ============================

// Volume calculation for a single row
function calculate_volume(frm, cdt, cdn) {
    let row = locals[cdt][cdn];
    if (!row) return;
    
    let L = ((row.l1 || 0) * 12) + (row.l2 || 0);
    let B = ((row.b1 || 0) * 12) + (row.b2 || 0);
    let H = ((row.h1 || 0) * 12) + (row.h2 || 0);
    
    row.volume = ((L * B * H) / 1728).toFixed(2);
    frm.refresh_field('stone_details');
    update_total_volume(frm);
}

// Total volume across all rows
function update_total_volume(frm) {
    let total = 0;
    (frm.doc.stone_details || []).forEach(r => {
        total += flt(r.volume);
    });
    frm.set_value('total_volume', total.toFixed(2));
}

// Load project flags from Baps Project
function load_project_flags(frm) {
    console.log('=== LOADING PROJECT FLAGS ===');
    console.log('Baps Project:', frm.doc.baps_project);
    
    if (!frm.doc.baps_project) {
        console.log('No Baps Project selected, clearing flags');
        frm._project_flags = { chemical: 0, dry_fitting: 0, polishing: 0 };
        set_child_grid_readonly(frm);
        return;
    }
    
    console.log('Fetching project document:', frm.doc.baps_project);
    frappe.db.get_doc('Baps Project', frm.doc.baps_project).then(project_doc => {
        if (project_doc) {
            console.log('Project document fetched:', project_doc);
            console.log('Project chemical:', project_doc.chemical);
            console.log('Project dry_fitting:', project_doc.dry_fitting); 
            console.log('Project polishing:', project_doc.polishing);
            
            // Store project flags for child table reference
            frm._project_flags = {
                chemical: project_doc.chemical ? 1 : 0,
                dry_fitting: project_doc.dry_fitting ? 1 : 0,
                polishing: project_doc.polishing ? 1 : 0
            };
            
            console.log('Project flags stored:', frm._project_flags);
            
            // Apply to all existing child rows
            apply_project_checkboxes(frm);
            
            // Set child grid readonly based on flags
            set_child_grid_readonly(frm);
            
            frappe.show_alert({
                message: `Project flags loaded: Chemical=${frm._project_flags.chemical}, Dry Fitting=${frm._project_flags.dry_fitting}, Polishing=${frm._project_flags.polishing}`,
                indicator: 'green'
            });
        }
    }).catch(err => {
        console.error('Error loading project flags:', err);
        frappe.show_alert({
            message: 'Error loading project flags: ' + err,
            indicator: 'red'
        });
        frm._project_flags = { chemical: 0, dry_fitting: 0, polishing: 0 };
    });
}

// ============================
// APPROVAL SYSTEM FUNCTIONS
// ============================

// Setup approval and publish buttons
function setup_approval_and_publish_buttons(frm) {
    // Remove ALL existing custom buttons to prevent duplicates
    Object.keys(frm.custom_buttons || {}).forEach(key => {
        if (frm.custom_buttons[key] && frm.custom_buttons[key].remove) {
            frm.custom_buttons[key].remove();
        }
    });
    frm.custom_buttons = {};

    // Primary button - Approve Selected Fields (with multiple fallback methods)
    frm.add_custom_button(__('Approve Selected Fields'), () => approve_selected_fields(frm))
        .addClass('btn-primary');
    
    // Alternative button - Approve All Filled Fields (simpler approach)
    frm.add_custom_button(__('Approve All Filled Fields'), () => approve_all_filled_fields(frm))
        .addClass('btn-info');

    // Check if all fields in all rows are filled and approved
    let all_complete = check_all_fields_complete(frm);
    
    if (all_complete) {
        // Show Publish button only when everything is complete
        frm.add_custom_button(__('Publish'), () => publish_data(frm))
            .addClass('btn-success');
    } else {
        // Show single progress message - only one button
        let progress = get_completion_progress(frm);
        frm.add_custom_button(__(`Progress: ${progress.filled}/${progress.total} fields`), () => {
            frappe.msgprint(__('Complete all fields to enable publishing.'));
        }).addClass('btn-secondary');
    }
}

// Check if all fields in all rows are completely filled
function check_all_fields_complete(frm) {
    if (!frm.doc.stone_details || frm.doc.stone_details.length === 0) return false;
    
    let required_fields = ['stone_name', 'stone_code', 'l1', 'b1', 'h1', 'l2', 'b2', 'h2', 'volume'];
    
    for (let row of frm.doc.stone_details) {
        for (let field of required_fields) {
            let value = row[field];
            if (value === undefined || value === null || value === '' || value === 0) {
                return false; // Found empty field
            }
        }
        
        // Also check if all fields are approved
        for (let field of required_fields) {
            if (!is_field_approved(frm, row, field)) return false;
        }
    }
    return true; // All fields filled and approved
}

// Get completion progress
function get_completion_progress(frm) {
    if (!frm.doc.stone_details) return {filled: 0, total: 0};
    
    let required_fields = ['stone_name', 'stone_code', 'l1', 'b1', 'h1', 'l2', 'b2', 'h2', 'volume'];
    let total_fields = frm.doc.stone_details.length * required_fields.length;
    let filled_fields = 0;
    
    frm.doc.stone_details.forEach(row => {
        required_fields.forEach(field => {
            let value = row[field];
            if (value !== undefined && value !== null && value !== '' && value !== 0) {
                filled_fields++;
            }
        });
    });
    
    return {filled: filled_fields, total: total_fields};
}

// Approve selected fields in selected rows
function approve_selected_fields(frm) {
    if (!frm.doc.stone_details || frm.doc.stone_details.length === 0) {
        frappe.msgprint(__('No rows to approve'));
        return;
    }
    
    // Method 1: Try to get selected rows from grid
    let selected_rows = [];
    
    // Check if grid exists and has selected rows
    let grid = frm.get_field('stone_details').grid;
    if (grid && grid.get_selected_children) {
        selected_rows = grid.get_selected_children();
    }
    
    // Method 2: Fallback - use jQuery to find selected checkboxes
    if (selected_rows.length === 0) {
        $('.grid-row').each(function() {
            let $row = $(this);
            let checkbox = $row.find('.grid-row-check input[type="checkbox"]');
            if (checkbox.length && checkbox.is(':checked')) {
                let row_index = parseInt($row.attr('data-idx'));
                if (!isNaN(row_index) && frm.doc.stone_details[row_index]) {
                    let row_doc = frm.doc.stone_details[row_index];
                    if (row_doc && !selected_rows.find(r => r.name === row_doc.name)) {
                        selected_rows.push(row_doc);
                        console.log('Found selected row:', row_index, row_doc.name);
                    }
                }
            }
        });
    }
    
    // Method 3: If still no selection, try alternative grid approach
    if (selected_rows.length === 0) {
        try {
            selected_rows = frm.fields_dict.stone_details.grid.get_selected();
        } catch (e) {
            console.error('Grid selection method failed:', e);
        }
    }
    
    // Method 4: If no rows selected, show dialog to select specific rows
    if (selected_rows.length === 0) {
        show_row_selection_dialog(frm);
        return;
    }
    
    let approved_count = 0;
    let required_fields = ['stone_name', 'stone_code', 'l1', 'b1', 'h1', 'l2', 'b2', 'h2', 'volume'];
    
    selected_rows.forEach(row => {
        approved_count += approve_filled_fields_in_row(frm, row, required_fields);
    });
    
    if (approved_count > 0) {
        frappe.show_alert({
            message: __('Approved {0} fields in {1} selected rows', [approved_count, selected_rows.length]),
            indicator: 'gray'
        });
        
        // Apply visual styling
        apply_all_field_approval_states(frm);
        
        // Update buttons
        setup_approval_and_publish_buttons(frm);
    } else {
        frappe.msgprint(__('No filled fields found to approve in selected rows'));
    }
}

// Show dialog to select rows when no rows are selected
function show_row_selection_dialog(frm) {
    if (!frm.doc.stone_details || frm.doc.stone_details.length === 0) {
        frappe.msgprint(__('No rows available'));
        return;
    }
    
    let row_options = frm.doc.stone_details.map((row, index) => {
        let stone_info = row.stone_name || `Row ${index + 1}`;
        let filled_count = count_filled_fields(row);
        return {
            label: `${stone_info} (${filled_count} fields filled)`,
            value: index
        };
    });
    
    frappe.prompt([
        {
            label: 'Select Rows to Approve',
            fieldname: 'selected_rows',
            fieldtype: 'MultiSelectPills',
            options: row_options,
            reqd: 1
        }
    ], function(values) {
        let selected_indices = values.selected_rows;
        if (!selected_indices || selected_indices.length === 0) {
            frappe.msgprint(__('No rows selected'));
            return;
        }
        
        let selected_rows = selected_indices.map(index => frm.doc.stone_details[index]);
        let approved_count = 0;
        let required_fields = ['stone_name', 'stone_code', 'l1', 'b1', 'h1', 'l2', 'b2', 'h2', 'volume'];
        
        selected_rows.forEach(row => {
            approved_count += approve_filled_fields_in_row(frm, row, required_fields);
        });
        
        if (approved_count > 0) {
            frappe.show_alert({
                message: __('Approved {0} fields in {1} selected rows', [approved_count, selected_rows.length]),
                indicator: 'gray'
            });
            
            // Apply visual styling
            apply_all_field_approval_states(frm);
            
            // Update buttons
            setup_approval_and_publish_buttons(frm);
        } else {
            frappe.msgprint(__('No filled fields found to approve in selected rows'));
        }
    }, __('Approve Fields'), __('Approve Selected'));
}

// Simpler approach - approve all filled fields in all rows
function approve_all_filled_fields(frm) {
    if (!frm.doc.stone_details || frm.doc.stone_details.length === 0) {
        frappe.msgprint(__('No rows to approve'));
        return;
    }
    
    let approved_count = 0;
    let required_fields = ['stone_name', 'stone_code', 'l1', 'b1', 'h1', 'l2', 'b2', 'h2', 'volume'];
    
    frm.doc.stone_details.forEach(row => {
        approved_count += approve_filled_fields_in_row(frm, row, required_fields);
    });
    
    if (approved_count > 0) {
        frappe.show_alert({
            message: __('Approved {0} filled fields across all rows', [approved_count]),
            indicator: 'gray'
        });
        
        // Apply visual styling
        apply_all_field_approval_states(frm);
        
        // Update buttons
        setup_approval_and_publish_buttons(frm);
    } else {
        frappe.msgprint(__('No filled fields found to approve'));
    }
}

// Count filled fields in a row
function count_filled_fields(row) {
    let required_fields = ['stone_name', 'stone_code', 'l1', 'b1', 'h1', 'l2', 'b2', 'h2', 'volume'];
    let count = 0;
    
    required_fields.forEach(field => {
        let value = row[field];
        if (value !== undefined && value !== null && value !== '' && value !== 0) {
            count++;
        }
    });
    
    return count;
}

// Approve filled fields in a single row (with persistent storage)
function approve_filled_fields_in_row(frm, row, required_fields) {
    if (!row._approved_fields) {
        row._approved_fields = {};
    }
    
    let approved_count = 0;
    
    required_fields.forEach(field => {
        let value = row[field];
        if (value !== undefined && value !== null && value !== '' && value !== 0) {
            if (!row._approved_fields[field]) {
                row._approved_fields[field] = true;
                // Save to persistent storage (localStorage)
                save_approval_state(frm, row.name, field, true);
                approved_count++;
            }
        }
    });
    
    return approved_count;
}

// Apply visual styling to all approved fields
function apply_all_field_approval_states(frm) {
    if (!frm.doc.stone_details) return;
    
    frm.doc.stone_details.forEach((row, row_index) => {
        // Check both _approved_fields and localStorage for approval states
        let required_fields = ['stone_name', 'stone_code', 'l1', 'b1', 'h1', 'l2', 'b2', 'h2', 'volume'];
        
        required_fields.forEach(field => {
            // Check if field is approved using the persistent storage function
            if (is_field_approved(frm, row, field)) {
                lock_individual_field(frm, row_index, field);
            }
        });
        
        // Also apply styling from _approved_fields (legacy support)
        if (row._approved_fields) {
            Object.keys(row._approved_fields).forEach(field => {
                if (row._approved_fields[field]) {
                    lock_individual_field(frm, row_index, field);
                }
            });
        }
        
        // Check if this row is fully approved and force gray styling
        if (is_row_fully_approved(frm, row)) {
            force_row_gray_styling(row_index);
        }
    });
}

// Lock individual field with visual styling
function lock_individual_field(frm, row_index, field) {
    setTimeout(() => {
        // Try multiple selector strategies for robust field selection
        let selectors = [
            `.grid-row[data-idx="${row_index}"] [data-fieldname="${field}"]`,
            `.grid-row:nth-child(${row_index + 1}) [data-fieldname="${field}"]`,
            `[data-fieldname="${field}"]`
        ];
        
        let $field = null;
        let $row = $(`.grid-row[data-idx="${row_index}"]`);
        
        // Try each selector until we find the field
        for (let selector of selectors) {
            if (selector === `[data-fieldname="${field}"]`) {
                // For the generic selector, filter by row
                $field = $(selector).filter(function() {
                    let $parent_row = $(this).closest('.grid-row');
                    let idx = $parent_row.attr('data-idx');
                    return idx == row_index || $parent_row.index() == row_index;
                });
            } else {
                $field = $(selector);
            }
            
            if ($field.length > 0) break;
        }

        if ($field && $field.length > 0) {
            $field.addClass('field-approved');
            
            // Make inputs truly uneditable
            $field.find('input, select, textarea').each(function() {
                $(this).prop('readonly', true)
                       .prop('disabled', true)
                       .addClass('field-approved-input')
                       .attr('title', 'This field is approved and locked');
            });
            
            // Prevent any click/focus events
            $field.find('input, select, textarea').off('click focus keydown keypress keyup change input')
                   .on('click focus keydown keypress keyup change input', function(e) {
                e.preventDefault();
                e.stopPropagation();
                frappe.show_alert({message: __('This field is approved and locked'), indicator: 'red'});
                return false;
            });
        } else {
            console.log(`Could not find field ${field} for row ${row_index}`);
        }
        
        // Check if this row should be fully grayed out
        let row_doc = frm.doc.stone_details[row_index];
        if (row_doc && is_row_fully_approved(frm, row_doc)) {
            // Make the entire row gray
            if ($row.length) {
                $row.addClass('row-fully-approved');
                
                // Style all elements in the row
                $row.find('*').each(function() {
                    $(this).css({
                        'background-color': '#f5f5f5 !important',
                        'color': '#666666 !important',
                        'border-color': '#bdbdbd !important'
                    });
                });
                
                // Specifically target all input elements
                $row.find('input, select, textarea, .form-control').each(function() {
                    $(this).css({
                        'background-color': '#f5f5f5 !important',
                        'color': '#666666 !important',
                        'border-color': '#bdbdbd !important'
                    }).prop('readonly', true).prop('disabled', true);
                });
                
                // Add visual indicator to row
                if (!$row.find('.row-approved-indicator').length) {
                    $row.find('.grid-row-index').append('<span class="row-approved-indicator">✓</span>');
                }
            }
        }
    }, 300);
}

// Publish data (final step)
function publish_data(frm) {
    frappe.confirm(
        __('Are you sure you want to publish this data? This will finalize all approvals.'),
        () => {
            // Add your publish logic here
            frappe.msgprint(__('Data published successfully!'));
            
            // You can add additional logic here such as:
            // - Setting a "published" flag
            // - Sending notifications
            // - Creating related documents
            // - etc.
        }
    );
}

// Check if a row has all its required fields approved
function is_row_fully_approved(frm, row) {
    let required_fields = ['stone_name', 'stone_code', 'l1', 'b1', 'h1', 'l2', 'b2', 'h2', 'volume'];
    
    for (let field of required_fields) {
        // Check if field has value and is approved
        let value = row[field];
        if (value !== undefined && value !== null && value !== '' && value !== 0) {
            if (!is_field_approved(frm, row, field)) {
                return false; // Found a filled field that's not approved
            }
        }
    }
    
    // Check if row has at least some approved fields
    let has_approved_fields = false;
    for (let field of required_fields) {
        if (is_field_approved(frm, row, field)) {
            has_approved_fields = true;
            break;
        }
    }
    
    return has_approved_fields;
}

// Force entire row to be gray when approved
function force_row_gray_styling(row_index) {
    setTimeout(() => {
        let $row = $(`.grid-row[data-idx="${row_index}"]`);
        if ($row.length) {
            // Apply gray styling to the entire row
            $row.css({
                'background': 'linear-gradient(90deg, #f5f5f5 0%, #e9e9e9 100%)',
                'border': '1px solid #bdbdbd',
                'border-radius': '4px'
            });
            
            // Style all cells in the row
            $row.find('td, .grid-static-col').each(function() {
                $(this).css({
                    'background-color': '#f5f5f5 !important',
                    'border-color': '#bdbdbd !important'
                });
            });
            
            // Style all inputs, selects, textareas
            $row.find('input, select, textarea, .form-control, .input-with-feedback').each(function() {
                $(this).css({
                    'background-color': '#f5f5f5 !important',
                    'color': '#666666 !important',
                    'border-color': '#bdbdbd !important'
                }).prop('readonly', true).prop('disabled', true);
            });
            
            // Style checkboxes and other elements
            $row.find('.grid-row-check, .grid-row-index').each(function() {
                $(this).css({
                    'background-color': '#f5f5f5 !important',
                    'color': '#666666 !important'
                });
            });
        }
    }, 500);
}

// ============================
// CSS STYLING
// ============================

// Add CSS styling for approved fields
if (!document.querySelector('#approval-field-styles')) {
    const style = document.createElement('style');
    style.id = 'approval-field-styles';
    style.textContent = `
        .field-approved {
            background-color: #e8f5e8 !important;
            border: 1px solid #4caf50 !important;
            position: relative;
            opacity: 1;
        }
        .field-approved::after {
            content: '✓';
            position: absolute;
            top: 2px;
            right: 5px;
            font-size: 12px;
            color: #2e7d32;
            font-weight: bold;
            pointer-events: none;
            z-index: 1000;
        }
        .field-approved-input {
            background-color: #f1f8e9 !important;
            color: #2e7d32 !important;
            cursor: not-allowed !important;
            pointer-events: none !important;
            border: 1px solid #81c784 !important;
        }
        .field-approved-input:focus,
        .field-approved-input:hover {
            background-color: #f1f8e9 !important;
            border-color: #81c784 !important;
            box-shadow: 0 0 0 0.2rem rgba(76, 175, 80, 0.25) !important;
        }
        .row-fully-approved {
            background: linear-gradient(90deg, #f5f5f5 0%, #e9e9e9 100%) !important;
            border: 1px solid #bdbdbd !important;
            border-radius: 4px;
            opacity: 1;
        }
        .row-fully-approved .grid-static-col,
        .row-fully-approved .grid-static-col input,
        .row-fully-approved .grid-static-col select,
        .row-fully-approved .grid-static-col textarea,
        .row-fully-approved .grid-row-check,
        .row-fully-approved .grid-row-index,
        .row-fully-approved [data-fieldname] {
            background-color: #f5f5f5 !important;
            color: #666666 !important;
            border-color: #bdbdbd !important;
        }
        .row-fully-approved td,
        .row-fully-approved .form-control,
        .row-fully-approved .input-with-feedback {
            background-color: #f5f5f5 !important;
            color: #666666 !important;
            border-color: #bdbdbd !important;
        }
        .row-approved-indicator {
            color: #2e7d32;
            font-weight: bold;
            margin-left: 5px;
            background: #4caf50;
            color: white;
            border-radius: 50%;
            padding: 2px 6px;
            font-size: 10px;
        }
        .approval-progress {
            font-weight: bold;
            color: #1976d2;
            margin: 5px 0;
        }
        
        /* Hover effects for approved elements */
        .row-fully-approved:hover {
            box-shadow: 0 4px 8px rgba(76, 175, 80, 0.15);
            transform: translateY(-1px);
            transition: all 0.2s ease-in-out;
        }
        
        /* Better styling for locked state */
        .row-fully-approved .grid-row-check {
            background-color: #e8f5e8 !important;
        }
    `;
    document.head.appendChild(style);
}

// ============================
// Additional Size List Details Handlers
// ============================

// --- Range Handler (supports "1-5" or "1,8,12" but NOT mixing) ---
frappe.ui.form.on('Size List Details', {
    range: function(frm, cdt, cdn) {
        let row = locals[cdt][cdn];
        if (!row || !row.range) return;

        let input = row.range.toString().trim();
        if (!input) return;

        // Disallow mixing comma + dash
        if (input.indexOf('-') !== -1 && input.indexOf(',') !== -1) {
            frappe.show_alert({message: "Invalid input → You cannot mix ranges and comma values", indicator: "red"});
            frappe.model.set_value(cdt, cdn, "range", "");
            return;
        }

        // Parse numbers
        let numbers = [];
        if (input.indexOf('-') !== -1) {
            let parts = input.split('-').map(s => s.trim());
            let start = cint(parts[0]), end = cint(parts[1]);
            if (isNaN(start) || isNaN(end) || start > end) {
                frappe.show_alert({message: "Invalid range → " + input, indicator: "red"});
                return;
            }
            for (let i = start; i <= end; i++) numbers.push(i);
        } else if (input.indexOf(',') !== -1) {
            numbers = input.split(',').map(s => cint(s.trim())).filter(n => !isNaN(n));
        } else {
            let n = cint(input);
            if (!isNaN(n)) numbers = [n];
        }

        numbers = [...new Set(numbers)].sort((a,b) => a-b);
        if (numbers.length === 0) return;

        // First row must have stone_code
        if (!row.stone_code) {
            frappe.show_alert({message: "Please enter Stone Code in the first row before using range", indicator: "red"});
            return;
        }

        let match = row.stone_code.match(/^(.*?)(\d+)$/);
        if (!match) {
            frappe.show_alert({message: "Stone Code must end with numbers, e.g. ABCDE001", indicator: "red"});
            return;
        }

        let prefix = match[1], num_width = match[2].length;

        // Clear range field
        frappe.model.set_value(cdt, cdn, "range", "");

        let duplicate_codes = [];

        numbers.forEach((n, idx) => {
            let stone_code = prefix + String(n).padStart(num_width, "0");

            let exists = frm.doc.stone_details.some(r => r.stone_code === stone_code || r.serial_no === n);
            if (exists) {
                duplicate_codes.push(stone_code);
                return;
            }

            let target_row;
            if (idx === 0) {
                target_row = row;
                target_row.stone_code = stone_code;
                target_row.serial_no = n;
            } else {
                target_row = frm.add_child("stone_details");
                Object.keys(row).forEach(f => {
                    if (!["name","idx","doctype","stone_code","range","serial_no"].includes(f)) {
                        target_row[f] = row[f];
                    }
                });
                target_row.stone_code = stone_code;
                target_row.serial_no = n;
            }

            calculate_volume(frm, target_row.doctype, target_row.name);
        });

        // Show non-blocking alert for duplicates
        if (duplicate_codes.length) {
            frappe.show_alert({
                message: "Skipped duplicates: " + duplicate_codes.join(", "),
                indicator: "orange"
            });
        }

        frm.refresh_field("stone_details");
    },

    // --- Dimension fields with inch validation ---
    l2: function(frm, cdt, cdn) {
        let row = locals[cdt][cdn];
        if (row.l2 >= 12) {
            frappe.msgprint(__('L2 must be less than 12 inches'));
            frappe.model.set_value(cdt, cdn, 'l2', 0);
        }
        calculate_volume(frm, cdt, cdn);
    },
    b2: function(frm, cdt, cdn) {
        let row = locals[cdt][cdn];
        if (row.b2 >= 12) {
            frappe.msgprint(__('B2 must be less than 12 inches'));
            frappe.model.set_value(cdt, cdn, 'b2', 0);
        }
        calculate_volume(frm, cdt, cdn);
    },
    h2: function(frm, cdt, cdn) {
        let row = locals[cdt][cdn];
        if (row.h2 >= 12) {
            frappe.msgprint(__('H2 must be less than 12 inches'));
            frappe.model.set_value(cdt, cdn, 'h2', 0);
        }
        calculate_volume(frm, cdt, cdn);
    },

    stone_details_remove: function(frm) {
        update_total_volume(frm);
    },

    // --- Controlled by Baps Project ---
    chemical: function(frm, cdt, cdn) {
        if (frm._project_flags?.chemical) {
            frappe.model.set_value(cdt, cdn, 'chemical', 1);
            frappe.msgprint(__("Chemical is controlled by the selected Baps Project and cannot be changed."));
        }
    },
    dry_fitting: function(frm, cdt, cdn) {
        if (frm._project_flags?.dry_fitting) {
            frappe.model.set_value(cdt, cdn, 'dry_fitting', 1);
            frappe.msgprint(__("Dry Fitting is controlled by the selected Baps Project and cannot be changed."));
        }
    },
    polishing: function(frm, cdt, cdn) {
        if (frm._project_flags?.polishing) {
            frappe.model.set_value(cdt, cdn, 'polishing', 1);
            frappe.msgprint(__("Polishing is controlled by the selected Baps Project and cannot be changed."));
        }
    },

    refresh: function(frm) {
        if (frm && frm.fields_dict && frm.fields_dict.stone_details) {
            let grid = frm.fields_dict.stone_details.grid;
            let chem_ro = frm._project_flags?.chemical ? 1 : 0;
            let dry_ro = frm._project_flags?.dry_fitting ? 1 : 0;
            let pol_ro = frm._project_flags?.polishing ? 1 : 0;
            grid.update_docfield_property('chemical', 'read_only', chem_ro);
            grid.update_docfield_property('dry_fitting', 'read_only', dry_ro);
            grid.update_docfield_property('polishing', 'read_only', pol_ro);
        }
    }
});

// --- Volume calculation for a single row ---
function calculate_volume(frm, cdt, cdn) {
    let row = locals[cdt][cdn];
    if (!row) return;
    let L = ((row.l1 || 0) * 12) + (row.l2 || 0);
    let B = ((row.b1 || 0) * 12) + (row.b2 || 0);
    let H = ((row.h1 || 0) * 12) + (row.h2 || 0);
    row.volume = ((L * B * H) / 1728).toFixed(2);
    frm.refresh_field('stone_details');
    update_total_volume(frm);
}

// --- Total volume across all rows ---
function update_total_volume(frm) {
    let total = 0;
    (frm.doc.stone_details || []).forEach(r => {
        total += flt(r.volume);
    });
    frm.set_value('total_volume', total.toFixed(2));
}

// --- Helper: set child grid checkboxes read-only based on project flags ---
function set_child_grid_readonly(frm) {
    if (!frm.fields_dict || !frm.fields_dict.stone_details) return;
    let grid = frm.fields_dict.stone_details.grid;
    let chem_ro = frm._project_flags?.chemical ? 1 : 0;
    let dry_ro = frm._project_flags?.dry_fitting ? 1 : 0;
    let pol_ro = frm._project_flags?.polishing ? 1 : 0;
    grid.update_docfield_property('chemical', 'read_only', chem_ro);
    grid.update_docfield_property('dry_fitting', 'read_only', dry_ro);
    grid.update_docfield_property('polishing', 'read_only', pol_ro);
}

// --- Apply project checkboxes to all child rows ---
function apply_project_checkboxes(frm) {
    console.log('=== APPLYING PROJECT CHECKBOXES ===');
    console.log('Current project flags:', frm._project_flags);
    
    // First, try to set the main form checkboxes (if they exist in Size List)
    if (frm._project_flags?.chemical !== undefined) {
        console.log(`Setting main form chemical=${frm._project_flags.chemical}`);
        frm.set_value('chemical', frm._project_flags.chemical);
    }
    if (frm._project_flags?.dry_fitting !== undefined) {
        console.log(`Setting main form dry_fitting=${frm._project_flags.dry_fitting}`);
        frm.set_value('dry_fitting', frm._project_flags.dry_fitting);
    }
    if (frm._project_flags?.polishing !== undefined) {
        console.log(`Setting main form polishing=${frm._project_flags.polishing}`);
        frm.set_value('polishing', frm._project_flags.polishing);
    }
    
    // Also apply to child table rows (if the fields exist there)
    console.log('Number of stone_details rows:', (frm.doc.stone_details || []).length);
    
    (frm.doc.stone_details || []).forEach((row, index) => {
        console.log(`Processing row ${index + 1}:`, row.name);
        
        if (frm._project_flags?.chemical) {
            console.log(`Setting chemical=1 for row ${index + 1}`);
            row.chemical = 1;
            frappe.model.set_value(row.doctype, row.name, 'chemical', 1);
        }
        if (frm._project_flags?.dry_fitting) {
            console.log(`Setting dry_fitting=1 for row ${index + 1}`);
            row.dry_fitting = 1;
            frappe.model.set_value(row.doctype, row.name, 'dry_fitting', 1);
        }
        if (frm._project_flags?.polishing) {
            console.log(`Setting polishing=1 for row ${index + 1}`);
            row.polishing = 1;
            frappe.model.set_value(row.doctype, row.name, 'polishing', 1);
        }
    });
    
    console.log('Refreshing stone_details field...');
    frm.refresh_field("stone_details");
    console.log('=== PROJECT CHECKBOXES APPLIED ===');
}
